"""Cif interface."""

import numpy as np

from cogue.crystal.cell import Cell
from cogue.crystal.utility import (
    frac2val,
    get_angles,
    get_lattice_parameters,
    lattice2cartesian,
)


def write_cif_P1(cell, filename=None):
    """Write P1 cif."""
    a, b, c = get_lattice_parameters(cell.lattice)
    alpha, beta, gamma = get_angles(cell.lattice)

    cif = """data_cogue_crystal_converter

_symmetry_space_group_name_H-M     'P 1'
_symmetry_Int_Tables_number        1

_cell_length_a                     %.5f
_cell_length_b                     %.5f
_cell_length_c                     %.5f
_cell_angle_alpha                  %.5f
_cell_angle_beta                   %.5f
_cell_angle_gamma                  %.5f
_cell_volume                       %.5f
_cell_formula_units_Z              1

loop_
_space_group_symop_operation_xyz
x,y,z

loop_
_atom_site_label
_atom_site_type_symbol
_atom_site_fract_x
_atom_site_fract_y
_atom_site_fract_z
_atom_site_occupancy\n""" % (
        a,
        b,
        c,
        alpha,
        beta,
        gamma,
        cell.get_volume(),
    )

    symbols = []
    for s, p in zip(cell.get_symbols(), cell.get_points().T):
        symbols.append(s)
        cif += "%-7s%2s %10.5f%10.5f%10.5f   1.00000\n" % (
            s + "%d" % symbols.count(s),
            s,
            p[0],
            p[1],
            p[2],
        )

    if filename is None:
        return cif
    else:
        w = open(filename, "w")
        w.write(cif)
        w.close()


def read_cif(str_cif):
    """Read cif file generated by openbabel.

    data_I
    _chemical_name_common 'filename.cif'
    _cell_length_a 4.0021
    _cell_length_b 13.8984
    _cell_length_c 3.6111
    _cell_angle_alpha 90
    _cell_angle_beta 90
    _cell_angle_gamma 90
    _space_group_name_H-M_alt 'C m m m'
    _space_group_name_Hall '-C 2 2'
    loop_
        _symmetry_equiv_pos_as_xyz
        'x,y,z'
        '-x,-y,z'
        '-x,y,-z'
        'x,-y,-z'
        '-x,-y,-z'
        'x,y,-z'
        'x,-y,z'
        '-x,y,z'
        '1/2+x,1/2+y,z'
        '1/2-x,1/2-y,z'
        '1/2-x,1/2+y,-z'
        '1/2+x,1/2-y,-z'
        '1/2-x,1/2-y,-z'
        '1/2+x,1/2+y,-z'
        '1/2+x,1/2-y,z'
        '1/2-x,1/2+y,z'
    loop_
        _atom_site_type_symbol
        _atom_site_label
        _atom_site_Cartn_x
        _atom_site_Cartn_y
        _atom_site_Cartn_z
        Er   Er1    -0.00000    5.00759    1.80555
        Ni   Ni2    -0.00000    2.77968    0.00000
        Pb   Pb3     0.00000    0.00000    0.00000
    """
    atom_site_order = []
    str_atom_site = ""
    str_symmetry_equiv_pos_as_xyz = ""
    loop_mode = False
    for line in str_cif.splitlines():
        if not line.strip():
            loop_mode = False
            continue

        if loop_mode:
            if "_symmetry_equiv_pos_as_xyz" in line:
                loop_mode = "symmetry_equiv_pos_as_xyz"
                continue
            elif "_atom_site_type_symbol" in line:
                atom_site_order.append("type_symbol")
                loop_mode = "atom_site"
                continue
            elif "_atom_site_label" in line:
                atom_site_order.append("label")
                loop_mode = "atom_site"
                continue
            elif "_atom_site_U_iso_or_equiv" in line:
                atom_site_order.append("U_iso_or_equiv")
                loop_mode = "atom_site"
                continue
            elif "_atom_site_thermal_displace_type" in line:
                atom_site_order.append("thermal_displace_type")
                loop_mode = "atom_site"
                continue
            elif "_atom_site_occupancy" in line:
                atom_site_order.append("occupancy")
                loop_mode = "atom_site"
                continue
            elif "_atom_site_Cartn_x" in line:
                atom_site_order.append("Cartn_x")
                loop_mode = "atom_site"
                continue
            elif "_atom_site_Cartn_y" in line:
                atom_site_order.append("Cartn_y")
                loop_mode = "atom_site"
                continue
            elif "_atom_site_Cartn_z" in line:
                atom_site_order.append("Cartn_z")
                loop_mode = "atom_site"
                continue
            elif "_atom_site_fract_x" in line:
                atom_site_order.append("fract_x")
                loop_mode = "atom_site"
                continue
            elif "_atom_site_fract_y" in line:
                atom_site_order.append("fract_y")
                loop_mode = "atom_site"
                continue
            elif "_atom_site_fract_z" in line:
                atom_site_order.append("fract_z")
                loop_mode = "atom_site"
                continue

        if "loop_" in line:
            loop_mode = True
        elif "_cell_length_a" in line:
            a = float(line.split()[1])
            loop_mode = False
            continue
        elif "_cell_length_b" in line:
            b = float(line.split()[1])
            loop_mode = False
            continue
        elif "_cell_length_c" in line:
            c = float(line.split()[1])
            loop_mode = False
            continue
        elif "_cell_angle_alpha" in line:
            alpha = float(line.split()[1])
            loop_mode = False
            continue
        elif "_cell_angle_beta" in line:
            beta = float(line.split()[1])
            loop_mode = False
            continue
        elif "_cell_angle_gamma" in line:
            gamma = float(line.split()[1])
            loop_mode = False
            continue

        if loop_mode == "symmetry_equiv_pos_as_xyz":
            str_symmetry_equiv_pos_as_xyz += line + "\n"
        elif loop_mode == "atom_site":
            str_atom_site += line + "\n"

    return _get_cell_from_cif_info(
        str_symmetry_equiv_pos_as_xyz,
        str_atom_site,
        atom_site_order,
        lattice2cartesian(a, b, c, alpha, beta, gamma),
    )


def _get_cell_from_cif_info(str_sym, str_atom, order, lattice):
    symbols, points = _read_atom_site_lines(str_atom, order, lattice)
    operations = _expand_symmetry_equiv_pos_as_xyz(str_sym)
    points = np.vstack((np.array(points), np.ones(len(symbols))))
    all_points = np.dot(operations[0], points)
    for opn in operations[1:]:
        all_points = np.hstack((all_points, np.dot(opn, points)))
    symbols = symbols * len(operations)
    red_symbols, red_points = _remove_overlapping_points(all_points, symbols)

    return Cell(lattice=lattice, points=red_points, symbols=red_symbols)


def _remove_overlapping_points(points, symbols, symprec=1e-2):
    red_pos = []
    red_sym = []

    for sym, pos in zip(symbols, points.T):
        ok = True
        for rpos in red_pos:
            diff = pos - rpos
            if (abs(diff.round() - diff) < symprec).all():
                ok = False
                break
        if ok:
            red_pos.append(pos)
            red_sym.append(sym)

    return red_sym, (np.array(red_pos) - np.floor(red_pos)).T


def _read_atom_site_lines(str_lines, atom_site_order, lattice):
    ind_symbol = atom_site_order.index("type_symbol")
    if "Cartn_x" in atom_site_order:
        index_x = atom_site_order.index("Cartn_x")
        index_y = atom_site_order.index("Cartn_y")
        index_z = atom_site_order.index("Cartn_z")
    if "fract_x" in atom_site_order:
        index_x = atom_site_order.index("fract_x")
        index_y = atom_site_order.index("fract_y")
        index_z = atom_site_order.index("fract_z")
    points = []
    symbols = []
    for line in str_lines.splitlines():
        vals = line.split()
        symbols.append(vals[ind_symbol])
        x = float(vals[index_x])
        y = float(vals[index_y])
        z = float(vals[index_z])
        points.append([x, y, z])

    points = np.transpose(points)
    if "Cartn_x" in atom_site_order:
        points = np.dot(np.linalg.inv(lattice), points)

    return symbols, points


def _expand_symmetry_equiv_pos_as_xyz(str_lines):
    operations = []
    for line in str_lines.splitlines():
        if line.strip():
            xyz = [x for x in line.translate(None, "' ").split(",")]
            operation = np.zeros((3, 4))
            for i, symbol in enumerate(xyz):
                parts = _split_xyz_symbol(symbol)
                for string in parts:
                    if "/" in string:
                        operation[i, 3] += frac2val(string)
                    if "x" in string:
                        operation[i, 0] += int(string.replace("x", "1"))
                    if "y" in string:
                        operation[i, 1] += int(string.replace("y", "1"))
                    if "z" in string:
                        operation[i, 2] += int(string.replace("z", "1"))

            operations.append(operation)

    return np.array(operations)


def _split_xyz_symbol(symbol):
    def plusminus(char):
        if char == "+" or char == "-":
            return True
        else:
            return False

    def xyz(char):
        if char == "x" or char == "y" or char == "z":
            return True
        else:
            False

    def slash(char):
        if char == "/":
            return True
        else:
            False

    parts = []
    string = ""
    for char in symbol:
        if plusminus(char):
            if string:
                parts.append(string)
            string = char
            continue
        if xyz(char):
            string += char
            parts.append(string)
            string = ""
            continue
        if slash(char):
            string += char
            continue
        if char.isdigit():
            string += char
            continue
    if string:
        parts.append(string)

    return parts
